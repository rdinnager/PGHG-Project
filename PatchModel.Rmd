---
title: "Exploring the Patch Model"
author: "Russell Dinnage"
date: "15/08/2014"
output: 
  html_document:
    highlight: pygments
---

```{r knitr_init, echo=FALSE, results="asis", cache=FALSE}
library(knitr)

## Global options
options(max.print="500")
opts_chunk$set(fig.path="out/",
               echo=TRUE,
               cache=TRUE,
               cache.path="cache2/",
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               autodep = TRUE)
opts_knit$set(width=75)
```

Here, I document some testing of a stochastic patch model, which will be used in conjunction with a phylogenetic simulation model, to look at the effects of phylogenetic diversity in a resource species, on the diversity of consumer species. The patch model is very simple. It consists of a number of sites that exist in a patch. Each site is occupied by a fixed resource species. In this model, resource species cannot go extinct --- they are properties of the patch. This makes sense because we are mainly interested in the short-term local effect of diversity (rather than the long-term co-evolutionary / metacommunity effects). An example would be a community of perrenial plants that stays relatively stable from year to year, with an associated community of insect herbivores which recruit into the perrenial plant communities.

Each time step of the model, a consumer species recruits into an unoccupied site in the patch with a probability $PP$ (pool probability). Once a species recruits into the patch, the species is chosen with an equal probability for each species in the pool. Sites that are already occupied become unoccupied at a rate equal to $d$ (death rate). Unoccupied sites are occupied by a consumer species already in the patch with probability $1 - PP$. The identity of the species is chosen with a probability equal to the consumption probability of the consumer species on the resource species in the site. When there is a single resource in a patch, and $PP = 1$, then this model is equivalent to a basic neutral model.

Let's try a run of the model to see what its output looks like. We use the package `deSolve` to run the model in 'iteration' mode. I also give the species in the simulation 'random' names.

```{r setup, dev='svg'}
library(PGHGproject)
library(randomNames)
data(randomNamesData)
set.seed(20140816)
## generate occupancy matrix
cnames <- paste(sample(names(c(randomNamesData$last_names_e4, randomNamesData$last_names_e5, 
                               randomNamesData$last_names_e3)), 20),
      sample(names(c(randomNamesData$last_names_e4, randomNamesData$last_names_e5, 
                     randomNamesData$last_names_e3)), 20))
rnames <- paste(sample(names(c(randomNamesData$first_names_e5_g0, randomNamesData$first_names_e5_g1, 
               randomNamesData$first_names_e1_g0, randomNamesData$first_names_e1_g1)), 30),
      sample(names(c(randomNamesData$first_names_e5_g0, randomNamesData$first_names_e5_g1, 
                     randomNamesData$first_names_e1_g0, randomNamesData$first_names_e1_g1)), 30))
ctree <- rcoal(20, cnames)
rtree <- rcoal(30, rnames)
plot(ctree)
plot(rtree, cex = 0.7)
occ_mat <- gen_CR_matrix(ctree, rtree, sig = 2, phi = c(0, 0, 0.5, 0.5, 0), alpha = logit(0.25))
## choose resource species to occupy patch
r_specs <- sample(rnames, 10)
## set-up model parameters
params <- list()
params$d <- 0.25
params$nspec <- 20
params$poolprob <- 0.05
params$ntype <- 10
params$occmat <- matrix(rbinom(params$nspec*params$ntype, 1, as.vector(occ_mat[, r_specs])), nrow = params$nspec, ncol = params$ntype)
params$type <- sample.int(10, size = 1000, replace = TRUE)
## run model
test <- ode(rep(0, 1000), c(1:200), stoch_patch, params, "iteration")
test[200, ]
```

The model output is a matrix, where each row gives a vector of species IDs, occupying each of the 1000 sites in the patch. We can get a count of each species in the patch using the `table` command in base R.

```{r table}
spec_tab <- table(factor(test[200, 2:1001], levels = as.character(seq_len(20))))
names(spec_tab) <- rownames(occ_mat)[as.numeric(names(spec_tab))]
spec_tab
```

The model behaves as expected, with the consumer species that was able to consume the most number of species in the patch, having the highest abundance (and also clearly the coolest name: "Zeferino Santiago Shugars").

```{r print_occmat, dev='svg'}
r_cons <- apply(params$occmat, 1, sum)
names(r_cons) <- rownames(occ_mat)
r_cons
plot(as.vector(spec_tab)~as.vector(r_cons))
```

I rolled the `table` summarization method into a function. Now we can track the consumer species over time.

```{r tab_time, dev='svg'}
time_spec <- apply(test[ , 2:1001], 1, c_tabulate, spec_names = rownames(occ_mat))
plot(time_spec["Zeferino Santiago Shugars", ], type = "l")
```

Okay, so that looks like it is working. Now, we will creat some phylogenetically structured resource communities, and run the model on them. We will make 30 over-, 30 under-, and 30 randomly dispersed communities.

```{r phylo_struct, dev='svg'}
pdist <- cophenetic(rtree)
comms <- rbind(make_OD_comms(pdist, rep(21, 30), prop = runif(30, 0.15, 0.95)),
               make_rand_comms(pdist, rep(21, 30), prop = runif(30, 0.15, 0.95)),
               make_UD_comms(pdist, rep(21, 30), prop = runif(30, 0.15, 0.95)))
## check if it worked
mean(mpd(samp = comms, dis = pdist)[1:30])
mean(mpd(samp = comms, dis = pdist)[31:60])
mean(mpd(samp = comms, dis = pdist)[61:90])
plot(mpd(samp = comms, dis = pdist))
```

Indeed, the underdispersed communities generally have a lower Mean Phylogenetic Distance (MPD) than the overdispersed and the random communities, but there is a decent amount of stochasticity there. Now to run our stochastic patch model on these communities. First, we need to create a function that will store all the necessary values for the model in an object, which we can then make a list of.

```{r phylo_patch}
patch_mod_ob <- function(comms, occmat, d, nspec, poolprob, nsites) {
  out <- list()
  ## choose resource species to occupy patch
  r_specs <- names(comms)[comms == 1]
  ## set-up model parameters
  params <- list()
  params$d <- d
  params$nspec <- nspec
  params$poolprob <- poolprob
  params$ntype <- length(r_specs)
  params$occmat <- matrix(rbinom(params$nspec*params$ntype, 1, as.vector(occ_mat[, r_specs])), nrow =
                            params$nspec, ncol = params$ntype)
  params$type <- sample.int(params$ntype, size = nsites, replace = TRUE)
  out$params <- params
  out$r_spec <- r_specs
  return(out)
}
patch_dat <- apply(comms, 1, patch_mod_ob, occmat = occ_mat, d = 0.25, nspec = 20, poolprob = 0.05, nsites = 1000)
test_comms <- lapply(patch_dat, function(x) ode(rep(0, 1000), c(1:200), stoch_patch, x$params, "iteration"))
```
